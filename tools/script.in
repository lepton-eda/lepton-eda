#!/usr/bin/env sh
exec @GUILE@ -s "$0" "$@"
!#

;;; The eval-when() macro allows to suppress compilation warnings
;;; on not defined variables because it evaluates the code on the
;;; expand stage before compilation.  This allows us to get Scheme
;;; module load paths we need before compilation, thus eliminating
;;; warnings on loading the modules afterwards.
(eval-when (expand load eval)
  (define %m4-bindir "@leptonbindir@")
  (define %m4-abs-top-srcdir "@abs_top_srcdir@")
  (define %m4-abs-top-builddir "@abs_top_builddir@")
  (define %m4-lepton-data-dir "@leptondatadir@")

  (define %program-name (car (program-arguments)))
  (define %running-program-absolute-file-name
    ;; If the program name is specified using its absolute or
    ;; relative path, canonicalize it.
    (or (false-if-exception
         (canonicalize-path %program-name))
        ;; When the program name is just a basename, we have to
        ;; use special means to obtain the real program path.

        ;; Try to implement a portable way of getting the path the
        ;; executable started from.

        ;; Linux
        (and (string-contains %host-type "linux")
             (readlink "/proc/self/exe"))
        ;; Other OSes can be added here, see the definition of the
        ;; variable %platform in the module (lepton-os) for
        ;; reference.

        ;; FreeBSD: sysctl CTL_KERN KERN_PROC KERN_PROC_PATHNAME -1
        ;; *BSD: (readlink "/proc/curproc/file")
        ;; Mac OS X: _NSGetExecutablePath()
        ;; Solaris: getexecname()
        ;; Windows: GetModuleFileName() with Module = NULL
        ))

  ;; Check if the program runs from its installation directory.
  (define run-installed-program? #t)
  (if (and run-installed-program?
           (not (getenv "LIBLEPTON")))
      (begin
        (add-to-load-path "@LEPTON_SCHEME_DIR@")
        (set! %load-compiled-path (cons "@LEPTON_CCACHE_DIR@" %load-compiled-path)))
      (begin
        ;; Do nothing for now.
        #f)))

(use-modules (lepton m4))
