<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <title></title>
  <link rel="stylesheet" media="screen" type="text/css" href="./style.css" />
  <link rel="stylesheet" media="screen" type="text/css" href="./design.css" />
  <link rel="stylesheet" media="print" type="text/css" href="./print.css" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>




<h3><a name="general_glue_and_related_gaf_projects" id="general_glue_and_related_gaf_projects">General, &quot;glue&quot; and related gaf projects</a></h3>
<div class="level3">

<p>
 These projects make the others work together as a system.
</p>

</div>

<h5><a name="autogeneration_of_fab_drawing_with_embedded_fab_notes" id="autogeneration_of_fab_drawing_with_embedded_fab_notes">Autogeneration of fab drawing with embedded fab notes</a></h5>
<div class="level5">

<p>
 This project involves creating a system which can create an annotated fab drawing from the drill file output by PCB, along with other inputs.  In one possible implementation, you could use LaTeX/metapost driven from an external script.  The script would read in some type of template holding boilerplate fab notes, insert a .eps version of the drill file, also read in some type of file holding stack-up information and other info for the PCB fab house, run LaTeX on it all, and then output an annotated .ps or .pdf fab drawing.  
</p>

<p>
Difficulty: 2
</p>

</div>

<h5><a name="create_comprehensive_test_suite_for_entire_geda_suite" id="create_comprehensive_test_suite_for_entire_geda_suite">Create comprehensive test suite for entire gEDA Suite</a></h5>
<div class="level5">

<p>
 This project encompasses the functionality of the entire gEDA PCB design flow. You would develop a test framework for as much of these tools as possible. This likely means creating a large regression test suite. Some examples are sets of layouts (using PCB) that just barely pass and just barely fail each of the different DRC checks, generate BOM’s, x-y files, generate gerbers and maybe use gerbv to do a graphical xor against a “golden” file. For gnetlist, reference netlists that have been placed into some canonical form should be generated from gschem schematics (.sch files).
</p>

<p>
This project should be fun for a hardware hacker, since it would involve creating all kinds of strange circuit designs, and you would learn the detailed ins-and-outs of all tools in the gEDA Suite!
</p>

<p>
Difficulty = 3
</p>

</div>

<h5><a name="usability_improvements_for_ngspice_gnucap" id="usability_improvements_for_ngspice_gnucap">Usability improvements for ngspice/Gnucap</a></h5>
<div class="level5">

<p>
 Ngspice and Gnucap are the gEDA Project’s analog circuit simulators. They are both command-line tools, meaning that you type commands into a shell-like program at a prompt. However, some popular commercial simulators support easy simulation and analysis directly from within a schematic capture <acronym title="Graphical User Interface">GUI</acronym>. This method of working is particularly well suited to newbies.
</p>

<p>
A new user would like to do the following things inside gschem: 
</p>
<ul>
<li class="level1"><div class="li"> Specify what kinds of simulations should be run</div>
</li>
<li class="level2"><div class="li"> Specify which voltages and currents should be plotted</div>
</li>
<li class="level2"><div class="li"> Start the simulation</div>
</li>
</ul>

<p>
 The simulation runs and the postprocessing may be in an extra program that is triggered by IPC. More thoughts about the project have been entered by Werner Hoch on the gEDA Wiki (<a href="geda-circuit_simulation_improvements.html" class="wikilink1" title="geda-circuit_simulation_improvements.html">Circuit simulation improvements</a>, <a href="geda-data_plotting_improvements.html" class="wikilink1" title="geda-data_plotting_improvements.html"> Plotting improvements</a>).
</p>

<p>
This project involves tightening the link between gschem and the back-end simulation programs. This might be done using some type of IPC, such as DBUS. Indeed, a preliminary DBUS implementation for gschem &harr; PCB already exists; the student might leverage the DBUS work for this project.
</p>

<p>
Difficulty = 3
</p>

</div>

<h5><a name="gschem_parts_manager_or_parts_database" id="gschem_parts_manager_or_parts_database">Gschem parts manager or parts database</a></h5>
<div class="level5">

<p>
 In this project, you would create a parts manager that takes a graphical symbol and a physical footprint, and marries the two to produce a heavy part. In addition, this tool should be able to support multiple backend flows. By this I mean that the parts manager should be able to also indicate how the symbol should be netlisted for spice, gnucap, or other backends. If possible it would be nice to integrate this into gschem in a way that allowed symbols to be placed and the footprint attribute to come up with a list of choices.
</p>

<p>
Another possible direction for improved parts management is to create a program like gattrib (or perhaps just re-use gattrib) which reads a bunch of .sch files, and also interfaces to an <acronym title="Structured Query Language">SQL</acronym> database holding all info about parts (including spice models, footprints, .pdf datasheets, etc) . The program would then allow users to perform database searches for footprints and other attributes stored as columns in the database.
</p>

<p>
Difficulty = 4
</p>

</div>

<h5><a name="gnetlist_gnetman_support_for_hierarchy" id="gnetlist_gnetman_support_for_hierarchy">Gnetlist/gnetman support for hierarchy</a></h5>
<div class="level5">

<p>
 The goal of this project is to create a scalable, professional-grade netlister. The project might involve re-writing gnetlist to enable hierarchical designs, or might involve upgrading “gnetman” to incorporate scripted back-ends. The upgrade would be done with an eye towards scalability. Ideally, highly capable and efficient internal data structures and methods for accessing the netlist database should be used. Then a scheme/guile <acronym title="Application Programming Interface">API</acronym> provided for an external script engine. (It may be beneficial to use swig to allow easy interfacing to multiple scripting languages.) The idea is to produce a netlister capable of handling large, hierarchical designs while still allowing users to write their own netlisters for their favorite netlist format (as gnetlist does now).
</p>

<p>
Gnetman is probably the logical starting point since the database was designed by someone with a lot of experience in EDA, and it uses datadraw which is a proven high power CASE tool. However, the student may take whatever approach he wishes, but should provide a strong argument that his approach makes sense before starting coding. In any event, It will be important to provide a compatibility <acronym title="Application Programming Interface">API</acronym> for the existing backends while providing a more high power and flexible <acronym title="Application Programming Interface">API</acronym> for new backends and improvements of the old ones.
</p>

<p>
Difficulty = 3
</p>

</div>

<h5><a name="language_translator_main_program" id="language_translator_main_program">Language translator main program</a></h5>
<div class="level5">

<p>
 The goal of this project is to write a driver file format translation, particularly for import and export of foreign formats.  A start already exists with gnucap language plugins.  It would be sort of like the existing “gnetlist” but be universal and able to translate in both directions.
</p>

<p>
This alone is too easy for the whole summer, but combined with support for one or two formats makes it good for the summer.
</p>

<p>
Difficulty = 1
</p>

</div>

<h5><a name="netlist_file_import_export" id="netlist_file_import_export">Netlist file import / export</a></h5>
<div class="level5">

<p>
 After we have the “translator main program”, above, we need plugins for the formats to import and export.  Gnucap already has support for Spice, Spectre, and Verilog, as plugins.  These plugins can be used with the system, and as examples of how others can be written.  The plugin needs to translate in both directions.
</p>

<p>
Obvious formats needed by the gEDA system are gschem, PCB, and Gerber.
</p>

<p>
Foreign formats needed, to provide a migration path between gEDA and other flows, include kicad, oregano, orcad, QUCS, LTspice, &hellip;.
</p>

<p>
This approach is a good way to implement translations asked for as other SOC suggestions.  (Gerber to PCB, PCB to IPC-356)
</p>

<p>
This is not a complete list.  One or two of them would make a good summer project.  More than one student can work on this.
</p>

<p>
The most difficult part of this project is studying and understanding the formats being imported and exported.
</p>

<p>
You can use the existing plugins for Verilog, Spectre, and Spice as examples.  The first one will take a while to learn the system, but after that they should be easy.
</p>

<p>
Difficulty = 1 to 5 depending on the format(s).
</p>

</div>
</body>
</html>
