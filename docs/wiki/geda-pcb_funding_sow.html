<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <title></title>
  <link rel="stylesheet" media="screen" type="text/css" href="./style.css" />
  <link rel="stylesheet" media="screen" type="text/css" href="./design.css" />
  <link rel="stylesheet" media="print" type="text/css" href="./print.css" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>


<p>
<strong>Statement of work:  Improving PCB&#039;s usability within the gEDA Suite framework</strong>
</p>

<h2 class="sectionedit485"><a name="background_and_motivation" id="background_and_motivation">Background and motivation</a></h2>
<div class="level2">

<p>
The open-source layout tool <a href="http://pcb.gpleda.org/" class="urlextern" title="http://pcb.gpleda.org/"  rel="nofollow">PCB</a> has been a member of the gEDA Project for many
years.  It is an essential part of the end-to-end design flow offered by the
gEDA tool set.  That is, although gschem/gnetlist can (in principle) support
many back-end PCB layout tools, the most advanced forward annotation tools
have been developed for PCB, and the vast majority (if not all) of the gEDA
Project&#039;s user base uses PCB as their layout tool.  PCB is a core part of the
gEDA Project&#039;s software offerings. 
</p>

<p>
For a variety of reasons, many electronics designers find PCB&#039;s user interface
difficult to master.  Many tasks are best performed using PCB&#039;s internal
command line (instead of menus or buttons), dropping to the unix shell, or
even hand-editing design files using scripts or emacs.  Some specific
shortcomings of PCB have been widely noted on the geda-* e-mail lists, along
with reasonable solutions.   A list of the biggest issues includes: 

</p>
<ul>
<li class="level1"><div class="li"> <strong>Forward annotation:</strong>  Difficulty forward annotating designs from gschem/gnetlist.  A separate command-line tool is used to carry the design from gschem to PCB.  This tool can produce design files out of synch with PCB.  Also, many electronics designers are unfamiliar with using the unix command line.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><acronym title="Graphical User Interface">GUI</acronym>:</strong>  PCB&#039;s <acronym title="Graphical User Interface">GUI</acronym> shows its age.  It has the following infelicitous properties:</div>
<ul>
<li class="level2"><div class="li"> It uses a mixture of noun/verb and verb/noun actions.  (Modern <acronym title="Graphical User Interface">GUI</acronym> programs are noun/verb only.)</div>
</li>
<li class="level2"><div class="li"> Incomplete menu/button coverage of possible editing actions.  For example, arbitrary rotation and component refdes renumbering are available only through the pop-up command entry window.</div>
</li>
<li class="level2"><div class="li"> There is a lack of <acronym title="Graphical User Interface">GUI</acronym> controls for exact, CAD-like editing. Examples for these desirable actions: Give the position of an object by typing its coordinates. Rotate an object by a given angle. Move objects by an exact amount. Do a multi copy of objects.</div>
</li>
<li class="level2"><div class="li"> Unlike many other graphical GUIs a dialog to edit properties of an object is missing in pcb. Properties to be edited might be layer, thickness, connected flag, polygon clearance, the net it belongs to, position, orientation, etc.</div>
</li>
<li class="level2"><div class="li"> Underlying the user interface, there is strong belief amongst PCB&#039;s developers that the supporting datastructures and methods are inadequate, and require upgrade as part of any <acronym title="Graphical User Interface">GUI</acronym> upgrade.</div>
</li>
</ul>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Footprint creation/editing:</strong>  Creating/editing footprints using PCB is difficult.  Most power users have created perl scripts to automate this process, but new users tend to be flummoxed by this approach.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Layers and design objects:</strong>  Although PCB can handle any arbitrary number of metal layers, it does not fully support other design layers as independent objects.  For example, it lacks full support for common layout layers like: keepout, DRC, outline, etc.  Also, the concept of padstacks is missing from PCB.  Finally, PCB does not provide the full DRC functionality expected of a modern layout program.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>DRC:</strong>  The existing mechanism to find DRCs is clumsy.  Also, a separate DRC layer which may be turned on or off (typical of modern layout programs) is missing.</div>
</li>
</ul>

<p>

We envision that addressing the above problems will provide a significant,
powerful benefit to PCB&#039;s usability within the larger framework of the gEDA
toolkit.  Addressing the usability issues will bring the following specific
benefits to the gEDA Project: 

</p>
<ul>
<li class="level1"><div class="li"> <strong>Adoption:</strong> Making PCB easier to use will lead to greater uptake of the entire gEDA electronic design toolkit by practicing engineers, including those working in commercial organizations.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Contribution:</strong>  More users implies more contributors.   In the context of the gEDA Project, this means not only software developers, but also people who will contribute schematic symbols, PCB footprints, utility scripts, and other collateral necessary to a thriving design environment.  (A strong focal point for contributors is – and will remain – the <a href="http://www.gedasymbols.org" class="urlextern" title="http://www.gedasymbols.org"  rel="nofollow">www.gedasymbols.org</a> website.)</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Support:</strong>  Engineers using the gEDA tools in a company context might be positioned to help organize funding for ongoing development of the gEDA Suite, thereby closing the circle from developers to users back to developers.  This would go a long way towards raising the gEDA Project above its current “advanced hobby hacker” status, a beneficial result for the entire gEDA ecosystem.</div>
</li>
</ul>

<p>

Therefore, the purpose of this document is to specify modifications to PCB
which we hope will bring about a renaissance in the gEDA Project itself by
making the critical tool PCB more accessible to the ordinary electronics
engineer. 
</p>

</div>
<!-- EDIT485 SECTION "Background and motivation" [86-4745] -->
<h2 class="sectionedit486"><a name="statement_of_work" id="statement_of_work">Statement of work</a></h2>
<div class="level2">

<p>
This section provides descriptions of what work is desired in each area of PCB&#039;s functionality.  This is not a full specification;  it is assumed that the person chosen to perform this work is familiar enough with the concepts associated with PCB design and the internals of PCB that this statement of work provides sufficient guidance about what to do.  

</p>
<hr />

</div>
<!-- EDIT486 SECTION "Statement of work" [4746-5135] -->
<h3 class="sectionedit487"><a name="general_guidelines" id="general_guidelines">General guidelines</a></h3>
<div class="level3">

</div>

<h4><a name="gtk_hid" id="gtk_hid">GTK HID</a></h4>
<div class="level4">

<p>
PCB supports several HIDs.  The HID is the interface layer which the user interacts with.  The two major HIDs provided for interactive use are based upon 1) the GTK <acronym title="Graphical User Interface">GUI</acronym> widget set, and 2) The X/Motif <acronym title="Graphical User Interface">GUI</acronym> widget set.  <strong>The work called out for this project shall be targeted at the GTK HID.</strong>  The reason for this is simple:  The rest of gEDA uses GTK.  A primary goal the renovation work in PCB is to more tightly bind PCB into the entire gEDA workflow.  More to the point:  the gEDA tool chain should present a more uniform interface to the user.  Users expect to see the same “look and feel” in all the tools they use.
However, any changes made as part of this work shall not break any feature present in any other HID, including the Motif HID.
</p>

</div>

<h4><a name="code_clarity" id="code_clarity">Code clarity</a></h4>
<div class="level4">

<p>
Many other changes are desirable in PCB.  However, they are outside the scope of this work.  The idea behind the changes specified here is that they create a launching point for other developers to come in afterward and continue improving PCB.  Therefore, <strong>the developer must strive to make his code clear and well commented.</strong>  Do not use hard to understand code tricks, obfuscating macros, or other devices which will hamper any follow-on work by other developers.
</p>

</div>

<h4><a name="doxygen" id="doxygen">Doxygen</a></h4>
<div class="level4">

<p>
The developer should place Doxygen comments into the header of any new function he writes.  Fully doxygenating PCB is outside the scope of this project, but <strong>the developer should at least use doxygen for the changes he makes.</strong>
</p>

</div>

<h4><a name="platforms" id="platforms">Platforms</a></h4>
<div class="level4">

<p>
The upgrades to PCB must work on the usual platforms supported by the gEDA Project.  Specifically:
</p>
<ul>
<li class="level1"><div class="li"> Linux, BSD, Sun.</div>
</li>
<li class="level1"><div class="li"> GTK version 2.8 or later (consistent with gschem 1.5 head).</div>
</li>
</ul>

<p>
Hooks for support on Windows systems are outside the scope of this project.  However, any Windows features present currently in PCB should not break as a result of these changes.
</p>

</div>

<h4><a name="backwards_compatibility" id="backwards_compatibility">Backwards compatibility</a></h4>
<div class="level4">

<p>
<strong>Any changes made to PCB should not break the ability of PCB to import existing
.pcb files.</strong>  It <strong>is</strong> allowed to break import of .new.pcb files (i.e. the output
of gsch2pcb).

</p>
<hr />

</div>
<!-- EDIT487 SECTION "General guidelines" [5136-7257] -->
<h3 class="sectionedit488"><a name="forward_annotation_upgrade" id="forward_annotation_upgrade">Forward annotation upgrade</a></h3>
<div class="level3">

<p>

<a href="geda-pcb_funding_sow-fwdann_ideas.html" class="wikilink1" title="geda-pcb_funding_sow-fwdann_ideas.html">Ideas, commentary, and examples from users</a>
</p>

</div>

<h4><a name="feature_description" id="feature_description">Feature description</a></h4>
<div class="level4">

<p>
The goal of forward annotation is to read the design information output from
e.g. a netlister, and use it to import all information required into PCB,
ready for use in creating or modifying a layout.  Reading the following
information is a required part of creating a PCB layout:

</p>
<ul>
<li class="level1"><div class="li"> Footprints with associated refdeses and their associated layers (if assigned).</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Graphical elements (pads, tracks, polygons, holes, etc)  (usually imported from a previous design iteration).</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Electronic connectivity (netlist).</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Any global design information such as routing constraints.  (Currently unsupported by PCB).</div>
</li>
</ul>

<p>

The scheme currently used by PCB is to read a file – already in PCB format –
containing the actual footprints embedded within it.  The netlist is read in
using a separate step.
</p>

<p>
The new scheme would read a file containing a list of actions.  Each line in
the file would correspond to a separate action.  The file would be generated
by a forward annotation tool (e.g. gsch2pcb).  The actions would correspond to
the atomic actions performed by PCB itself when it finds a footprint by
searching its footprint library.  
</p>

<p>
For example, one line in the forward annotation file might say
“(load-element-data SOT-23 U6)”.  This would make PCB look for an SOT-23
package in its footprint library (using PCB&#039;s $FOOTPRINT_PATH), place it in a
waiting position on the PCB, and give it the refdes “U6”.  Another action
might say “(add-line &lt;layer&gt; &lt;X1&gt; &lt;Y1&gt; &lt;X2&gt; &lt;Y2&gt; &lt;width&gt; &lt;flags&gt;)”, which
would add a straight line segment onto layer &lt;layer&gt; from position (X1, Y1) to
position (X2, Y2) having width &lt;width&gt; and flags &lt;flags&gt;.  (The flags would
specify things like whether the line ends are round or square, along with the
other properties of a line.)
</p>

<p>
Besides importing footprint and graphical information, the new PCB forward
annotation facility should import the netlist at the same time as the rest of
the layout information.  (This is currently a separate step, which is
inconsistent with the goal of ease-of-use.)
</p>

<p>
Note that the above descriptions of the actions are meant to provide examples
of how PCB should be modified.  The details of each action are to be
determined by the developer and the architecture of PCB itself.
</p>

</div>

<h4><a name="use_cases" id="use_cases">Use cases</a></h4>
<div class="level4">

<p>
Once the forward annotation changes are complete, the following use cases should apply:
</p>

<p>
<strong>New PCB</strong>
</p>
<ol>
<li class="level1"><div class="li"> The user creates his design using gschem.  </div>
</li>
<li class="level1"><div class="li"> He creates a forward annotation file by running the .sch files through gsch2pcb, which creates a single .pfa (PCB forward annotation) file.</div>
</li>
<li class="level1"><div class="li"> The user starts PCB.</div>
</li>
<li class="level1"><div class="li"> He clicks “File → new PCB”.  A window pops up, providing a place to enter the new board&#039;s layer count and size.  The window may also provide a way to specify common board templates (PC-104, 3U Eurocard, etc.)</div>
</li>
<li class="level1"><div class="li"> The new board is shown in PCB&#039;s main window as a white area on a darker background (as currently implemented).</div>
</li>
<li class="level1"><div class="li"> The user clicks “File → Import forward annotation file”.</div>
</li>
<li class="level1"><div class="li"> A file selection window pops up.  The user clicks on his .pfa file and clicks OK.</div>
</li>
<li class="level1"><div class="li"> PCB reads each action in the forward annotation file, and does the corresponding thing.  </div>
</li>
<li class="level1"><div class="li"> The PCB netlist is also imported during this activity.  No separate netlist readin step is required.</div>
</li>
<li class="level1"><div class="li"> At the end of the file&#039;s read-in, the footprints should be present on the board (*not* in the paste buffer), ready to be disbursed and placed.</div>
</li>
</ol>

<p>

<strong>Existing PCB</strong>
</p>
<ol>
<li class="level1"><div class="li"> The user has a pre-existing .pcb file for the design under consideration.  He makes changes to his design using e.g. gschem or gattrib.  </div>
</li>
<li class="level1"><div class="li"> The creates a forward annotation file by running the .sch files through gsch2pcb, which creates a single .pfa (PCB forward annotation) file.  </div>
</li>
<li class="level1"><div class="li"> The user starts PCB (or re-activates an existing PCB session running in its window).</div>
</li>
<li class="level1"><div class="li"> The user clicks “File → Import forward annotation file”.</div>
</li>
<li class="level1"><div class="li"> A file selection window pops up.  The user clicks on his .pfa file and clicks OK.</div>
</li>
<li class="level1"><div class="li"> PCB reads each action in the forward annotation file, and does the corresponding thing. Using the refdes, the importer looks to see if the component in the forward annotation file is already placed in PCB, and if so, it ignores the action.  </div>
</li>
<li class="level1"><div class="li"> The netlist is also read in and updated at this stage.  No separate netlist readin step is required.</div>
</li>
<li class="level1"><div class="li"> Once this action is complete, the user is ready to continue editing his board. </div>
</li>
</ol>

</div>

<h4><a name="other_ideas" id="other_ideas">Other Ideas</a></h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Besides a menu option, there should be a toolbar button to sync changes</div>
</li>
<li class="level1"><div class="li"> Alternately, a thread running a file change monitor can spot the new annotation file when it appears</div>
</li>
<li class="level1"><div class="li"> Finally, the project manager (gsch2pcb / xgsch2pcb / geda_manager) can invoke readin of a forward annotation file via IPC</div>
</li>
</ul>

</div>

<h4><a name="work_required" id="work_required">Work required</a></h4>
<div class="level4">

<p>
Some of the support for forward annotation already exists.  Specifically, many
actions are already supported.  Therefore, this project involves:
</p>
<ol>
<li class="level1"><div class="li"> Creating the missing actions required for full forward annotation.</div>
</li>
<li class="level1"><div class="li"> Creating a method for reading in an action script.</div>
</li>
<li class="level1"><div class="li"> Integrating the new script-based forward annotation into PCB&#039;s <acronym title="Graphical User Interface">GUI</acronym>.</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup.</div>
</li>
</ol>
<hr />

</div>
<!-- EDIT488 SECTION "Forward annotation upgrade" [7258-12531] -->
<h3 class="sectionedit489"><a name="gui_modernization" id="gui_modernization">GUI modernization</a></h3>
<div class="level3">

<p>

<a href="geda-pcb_funding_sow-gui_ideas.html" class="wikilink1" title="geda-pcb_funding_sow-gui_ideas.html">Ideas, commentary, and examples from users</a>
</p>

<p>
The basic goal is to make the upgraded PCB behave exactly as an inexperienced
user might expect, based upon his familiarity with modern <acronym title="Graphical User Interface">GUI</acronym>-based tools like
OpenOffice.  This means:

</p>
<ul>
<li class="level1"><div class="li"> PCB should support all the “normal” keystrokes which have become defacto standards for <acronym title="Graphical User Interface">GUI</acronym> programs.  Examples include &lt;ctrl&gt;-c for copy, &lt;ctrl&gt;-x for delete, etc.  PCB may continue to support the old key strokes to maintain backward compatibility for those who are already experienced with the program, but in the event that one of PCB&#039;s current keystrokes conflicts with the “defacto standard”, the defacto standard shall be implemented.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> PCB should support all actions using “noun/verb” syntax.  Details of this upgrade are presented in the “actions” section below.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> PCB should support normal selection modes (i.e. ways to select an object for editing or modification).    Details of this upgrade are presented in the “selection methods” section below.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> PCB&#039;s internals should be upgraded to easily support enhanced menus and button bars.  This means upgraded callbacks and possibly also a resource file which specifies things like menu layout, menu options available, and keybindings.</div>
</li>
</ul>

<p>

If the descriptions in this specification are ambiguous or unclear, use the behaviors implemented in gschem as the preferred example.
</p>

</div>

<h4><a name="actions" id="actions">Actions</a></h4>
<div class="level4">

<p>
The following actions should be modified to support a “noun/verb” actions,
if they do not support it already.  Where possible, support for the current
“verb/noun” actions should not be dropped to maintain compatibility for
users who have learned the old actions.  However, if there is a conflict
between the new noun/verb and the old verb/noun actions, the new noun/verb
actions take presidence.

</p>
<ul>
<li class="level1"><div class="li"> <strong>select/delete</strong>  Using any of: menu item, &lt;ctrl&gt;-x.  Delete should move the deleted object(s) from the layout into the copy buffer, so the user may place them elsewhere with a subsequent action.  (NOTE:  The copy buffer should probably be implemented separately from the existing “element buffer”.)</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>select/remove</strong>  Using any of menu item, &lt;del&gt;, character d.  Remove should permanently remove the selected item.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>select/move</strong>  Using: left mouse button down and drag.  Also:  Select, then use arrow keys to move the selected objects some small quantum of motion (perhaps the grid spacing) in the direction specified by the arrow.  </div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>select/copy</strong>  Using any of: menu item, copy button, character c. &lt;ctrl&gt;-c.  This should copy the selected items into the copy buffer so the user may place them elsewhere in a subsequent action.  (NOTE:  The copy buffer should probably be implemented separately from the existing “element buffer”.)</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>paste</strong>  Using any of: menu item, paste button, &lt;ctrl&gt;-v.  This will bring the contents of the copy buffer into action at the cursor.  When the user clicks on the design, then the elements will be placed on the layout where the user clicks.  Refer to the behavior of gschem to see exactly how this should work.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>select/move selection to current layer</strong>  Using menu item, </div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>select/move object to opposite layer</strong> Using menu item, &lt;shift&gt;-c.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>select/report object properties</strong>  Using menu item or &lt;ctrl&gt;-r.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>select/edit object properties</strong>  Using menu item or double click on single object.  This is a new action.<br/>
If the selected object is a graphical primitive (line, arc, etc), PCB will open up a window displaying the object properties in an editable window, allowing for the user to modify the object&#039;s properties.  For example double clicking on a Cu track should open up the edit window, showing the track&#039;s width, current layer, end type (round vs. square), and its beginning and end coordinates.<br/>
If the selected object is a footprint, PCB will open up a window allowing the user to select a different footprint name.  Some type of footprint browsing window with previewing should be presented to the user for this.  The footprints should be found by looking through PCB&#039;s footprint search path.  Recommendation: steal the symbol browser window from gschem for this task.  (Question:  how to back annotate this info into the .sch files?)<br/>
If the selected object is text, then PCB should open up the text edit dialog box, allow the user to edit his text, click OK, and the text on the layout should be updated.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Select/rotate</strong>  Using menu item or &lt;ctrl&gt;-r.  This is a new window (the action already exists).  This will open a window asking the user to type in a rotation angle.  The user will type in the angle (in degrees), click OK, and the selected item will be rotated.  Ideally, the rotation would apply globally to a selected set of items; it is up to the developer to determine if this is feasible. If not, then rotate should apply to only one item.</div>
</li>
</ul>

</div>

<h4><a name="selection_modes" id="selection_modes">Selection modes</a></h4>
<div class="level4">

<p>
The following selection modes must be supported:
</p>
<ul>
<li class="level1"><div class="li"> mouse click on single object.</div>
</li>
<li class="level1"><div class="li"> &lt;ctrl&gt;-click on multiple objects.  (Example:  &lt;ctrl&gt;-click this 1, &lt;ctrl&gt;-click this 2, &lt;ctrl&gt;-click this 3, etc.)</div>
</li>
<li class="level1"><div class="li"> Click and drag to select objects within a rectangular area.</div>
</li>
<li class="level1"><div class="li"> &lt;esc&gt; clears all selections</div>
</li>
<li class="level1"><div class="li"> &lt;ctrl&gt;-a selects all objects in the design.</div>
</li>
<li class="level1"><div class="li"> &lt;ctrl&gt;-A selects all connected objects.  (Question:  What is this selection mode useful for?)</div>
</li>
</ul>

</div>

<h4><a name="work_required1" id="work_required1">Work required</a></h4>
<div class="level4">

<p>
This project involves:
</p>
<ol>
<li class="level1"><div class="li"> Refactoring and upgrade of program internals to support noun/verb actions.  </div>
</li>
<li class="level1"><div class="li"> Create new windows (e.g. object editor, move, rotate, etc.).  </div>
</li>
<li class="level1"><div class="li"> Refactoring and upgrade of program internals to support selection modes.</div>
</li>
<li class="level1"><div class="li"> Implementation of <acronym title="Graphical User Interface">GUI</acronym> resource file which is read in upon program start to configure user interface.</div>
</li>
<li class="level1"><div class="li"> <acronym title="Graphical User Interface">GUI</acronym> upgrade.  Specifically, hook up the callbacks to the menu items and buttons defined in the <acronym title="Graphical User Interface">GUI</acronym> resource file.</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup.</div>
</li>
</ol>
<hr />

</div>
<!-- EDIT489 SECTION "GUI modernization" [12532-18467] -->
<h3 class="sectionedit490"><a name="footprint_editor_implementation" id="footprint_editor_implementation">Footprint editor implementation</a></h3>
<div class="level3">

<p>
Incorporating a good footprint editor into PCB is a common request from users.
It is important for PCB to clearly distinguish between editing a footprint and
editing an entire PCB design.  Here are two possible methods to accomplish
this:
</p>
<ol>
<li class="level1"><div class="li"> Although it is not optimal, the symbol editing mode present in gschem provides a reference for how this might be implemented.  Specifically, editing a footprint may be implemented as a “mode”, in which the user drills down into the footprint, and is placed into a special mode of the standard PCB editing window which is reserved for editing footprints.  </div>
</li>
<li class="level1"><div class="li"> Another way to implement a footprint editor is to have a pop-up window with its own drawing pane along with editing widgets specialized for creating and modifying footprints.</div>
</li>
</ol>

<p>
Optionally, features involving editing footprints via the buffer will be removed.  Alternately, retain the option allowing the user to draw in the main window, select, then invoke some menu option to convert the selection to a footprint.  This option may exist <strong>alongside</strong> the new footprint editor.
</p>

</div>

<h4><a name="invocation" id="invocation">Invocation</a></h4>
<div class="level4">

<p>
There are two ways to invoke the footprint editor:
</p>
<ol>
<li class="level1"><div class="li"> Create a new footprint.  In this case the user will have no object selected on the PCB drawing window.  He will then choose an option from the menu, like “tools → down footprint”.  This will place the user into the footprint editor, and the drawing area will be empty</div>
</li>
<li class="level2"><div class="li"> Edit an existing footprint.  In this case, the user will select a footprint present on the board by clicking on it.  Then he will select an option from the menu, like “tools → down footprint”.  This will place the user into the footprint editor, and the drawing area will hold a copy of the selected footprint, ready for editing.</div>
</li>
</ol>

<p>

As a third possibility, the user should be able to do “tools → create new footprint”, go into the editor, and then do “file → open” and select a footprint from the library to edit.
</p>

<p>
As a fourth possibility, allow a mode similar to gschem, where a library browser is used to select and place primitive objects.  That would save the user from needing to know where the library files are hidden.
</p>

</div>

<h4><a name="editing" id="editing">Editing</a></h4>
<div class="level4">

<p>
The footprint editor should be a graphical drawing environment similar to that presented by PCB for layout editing.

</p>
<ul>
<li class="level1"><div class="li"> Buttons and menus.  The footprint editor should have all the same menus and buttons as are available from the PCB editor.  Those menu items and buttons which are not useful for footprint editing should be greyed out.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Look and feel.  Once the user is placed in the footprint editor, the PCB window should change in some way to reflect that the user is in a different mode.  For example, the title bar must say “footprint mode”.  Also, the drawing field background color might be changed a little bit to emphasize the change in mode.</div>
</li>
</ul>

<p>

The design choice of which environment is better is left to the developer to decide based upon factors including input from the community, ease of implementation, etc.
</p>

</div>

<h4><a name="saving" id="saving">Saving</a></h4>
<div class="level4">

<p>
Once the user has edited his footprint, he will want to save it out.  This is
a problematic action, since it&#039;s not a good idea to allow the user to
overwrite a footprint living in the footprint libraries.  Moreover, the user
may not have write access to the library directories.   
</p>

<p>
Therefore, when the user is done editing his footprint, there should be only
one save action available under the file menu:  “file → save footprint as”.
This will call up the file save dialog, which will default to sticking the
footprint in the current working directory (or the last directory he saved a
footprint into during this session).  The user will then be required to browse
to his preferred save directory, and save the footprint there.  
</p>

</div>

<h4><a name="leaving" id="leaving">Leaving</a></h4>
<div class="level4">

<p>
Once the footprint editing session is done, the user may leave the editor and
return to his main PCB editing session.  This may be accomplished using a menu
item like “tools → up to layout”.  If any unsaved changes remain in the
footprint, then the user should be prompted to either save or discard his
changes before leaving the footprint editor.
</p>

</div>

<h4><a name="updating_a_footprint_placed_on_the_board" id="updating_a_footprint_placed_on_the_board">Updating a footprint placed on the board</a></h4>
<div class="level4">

<p>
After editing a footprint and saving it out, the user will often want to
update a footprint already present on the PCB.  Here is the preferred method
(use case) to do this:
</p>
<ol>
<li class="level1"><div class="li"> User selects footprint to update.</div>
</li>
<li class="level1"><div class="li"> From menu, user selects “tools → update footprint”.  A keystroke to start this action may also be provided.</div>
</li>
<li class="level1"><div class="li"> A pop-up window opens, giving the user the footprint browser (as described above).  The window will have has default footprint the name of the currently selected footprint.  </div>
</li>
<li class="level1"><div class="li"> The user will either accept the default footprint presented, or he may search for a different footprint.  When he is done, he will click OK.</div>
</li>
<li class="level1"><div class="li"> PCB will load the specified footprint from its library.  Note:  For this to work after editing a footprint, the user must place his local directory first on the footprint search path.</div>
</li>
<li class="level1"><div class="li"> PCB will then replace the old footprint on the board with the one pulled from the library.  The old footprint (currently written into the .pcb file) will go away, and the new one will take its place.</div>
</li>
</ol>

</div>

<h4><a name="work_required2" id="work_required2">Work required</a></h4>
<div class="level4">

<p>
This project involves:
</p>
<ol>
<li class="level1"><div class="li"> Create internal structures and methods needed to support a separate footprint editor.</div>
</li>
<li class="level1"><div class="li"> Create footprint editing window (if the separate window approach is adopted).</div>
</li>
<li class="level1"><div class="li"> Integrate access to footprint editor into main PCB <acronym title="Graphical User Interface">GUI</acronym>.</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup.</div>
</li>
</ol>
<hr />

</div>
<!-- EDIT490 SECTION "Footprint editor implementation" [18468-24056] -->
<h3 class="sectionedit491"><a name="upgrade_of_layer_and_design_objects" id="upgrade_of_layer_and_design_objects">Upgrade of layer and design objects</a></h3>
<div class="level3">

</div>

<h4><a name="feature_description1" id="feature_description1">Feature Description</a></h4>
<div class="level4">

<p>
Currently, PCB&#039;s internal data structures only “know” about metal and silk
layers.  Other layers commonly used in PCB design are either missing (e.g. DRC
layer, outline layer), or are simply derived from the metal layer (solder
mask).  This task involves implementing full support for layers of arbitrary
type and layer count.  Also, support for other design objects is part of this
upgrade.  Specific features required are:

</p>
<ul>
<li class="level1"><div class="li"> Upgrade of existing datastructures to support layers of arbitrary type including: DRC, mechanical outline, annotation, solder mask, paste mask, plated through-hole, unplated through-hole, metal, silk.  The upgrade must also provide support for an arbitrary number of layers.  Also, allowing for per-layer clearance settings is an important feature for inclusion here.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Implement window widget allowing for easy selection/configuration of layer stack-up.  Parameters to configure include:  layer count, layer type, layer polarity, layer visibility, layer color.  The window will also allow the user to re-order the layers (from front to back), and to add or subtract an arbitrary number of layers.  The layer window presented in “gerbv” is a reasonable example of what this window should support.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Implement a new datastructure representing a pad stack.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Implement a window widget allowing for easy editing of the pad stack&#039;s properties, including: metal annulus outer diameter (per layer), solder mask diameter (per layer), paste mask diameter (per layer), clearance width (per layer), hole diameter.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Consider how the data-structures could allow support for blind or burried vias in the future.</div>
</li>
</ul>

</div>

<h4><a name="work_required3" id="work_required3">Work required</a></h4>
<div class="level4">

<p>
This project involves:
</p>
<ol>
<li class="level1"><div class="li"> Upgrade internal structures and methods to enable full layer support.</div>
</li>
<li class="level1"><div class="li"> Create layer configuration window.</div>
</li>
<li class="level1"><div class="li"> Create internal datastructures and methods to support padstacks.</div>
</li>
<li class="level1"><div class="li"> Create padstack configuration window.</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup.</div>
</li>
</ol>
<hr />

</div>
<!-- EDIT491 SECTION "Upgrade of layer and design objects" [24057-26082] -->
<h3 class="sectionedit492"><a name="design_rule_checking_upgrade" id="design_rule_checking_upgrade">Design Rule Checking Upgrade</a></h3>
<div class="level3">

</div>

<h4><a name="feature_description2" id="feature_description2">Feature Description</a></h4>
<div class="level4">

<p>
The goal of design rule checking (DRC) is to insure that a printed circuit
board layout conforms to a set of design rules.  Design rules will consist of
specifications like minimum copper line width, minimum copper spacing,
etc. Generating a manufacturable PCB layout without DRC is tedious at best
</p>

<p>
The current PCB DRC steps through design rule violations one by one using a
dialog box that reports the error, the coordinate position of the error and
places the cursor at the error. Bouncing back and forth between the layout and
the dialog box is time consuming. Knowing all of the errors prior to starting
error correction is usually more productive.
</p>

<p>
A preferred method of reporting DRC violations would be to graphically
indicate all errors on the layout. With this method all errors are quickly
visible. DJ has suggested a layer for displaying DRC errors.  The user should
be able to turn the layer visibility on and off.
</p>

<p>
A useful option for DRC would be to have it run periodically.  A proactive DRC
should help novices avoid creating multiple similar errors.  Threaded operation, 
or a DRC which works in packets of time where the
mainloop hits idle would be possibilities here. Both have their merits
and draw-backs. If the operation is slow, we&#039;ll need some way to queue
the work such that updates to the board in the mean time queue updates
for new DRC checking. 
</p>

<p>
Similarly, we&#039;d need to ensure that removing or
changing objects on the board doesn&#039;t crash the DRC code - if it is
running in a thread.
</p>

</div>

<h4><a name="use_cases1" id="use_cases1">Use Cases</a></h4>
<div class="level4">

<p>
<strong>Manual DRC</strong>
</p>
<ol>
<li class="level1"><div class="li"> The user runs DRC using either a hot-key or menu item. An unobtrusive DRC status indicator is displayed. Perhaps the phrase “DRC Check” in yellow text in the top bar.</div>
</li>
<li class="level1"><div class="li"> DRC violation marks are displayed on the DRC layer or on the PCB the layout.</div>
</li>
<li class="level1"><div class="li"> An unobtrusive DRC status indicator is displayed.  Perhaps the phrases “DRC PASS” in green text and “DRC FAIL” in red text in the top bar.</div>
</li>
<li class="level1"><div class="li"> If there are DRC failures the user can step to the next error manually or by using a hot-key. After changes are made the DRC can be run manually to verify the fix.</div>
</li>
</ol>

<p>

<strong>Automatic DRC</strong>
</p>
<ol>
<li class="level1"><div class="li"> Using a menu item the user can set the appropriate time interval for running DRC. A default value is used if a new value is not set.</div>
</li>
<li class="level1"><div class="li"> The user enables automatic DRC mode.</div>
</li>
<li class="level1"><div class="li"> After the DRC idle period has elapsed DRC runs.  An unobtrusive DRC status indicator is displayed. Perhaps the phrase “DRC Check” in yellow text in the top bar.</div>
</li>
<li class="level1"><div class="li"> DRC violation marks are displayed on the DRC layer or on the PCB layout.</div>
</li>
<li class="level1"><div class="li"> An unobtrusive DRC status indicator is displayed.  Perhaps the phrase “DRC PASS” in green text and “DRC FAIL” in red text in the top bar.</div>
</li>
<li class="level1"><div class="li"> If there are DRC failures the user can step to the next error manually or by using a hot-key. After changes are made the DRC can be run manually to verify the fix.</div>
</li>
</ol>

</div>

<h4><a name="work_required4" id="work_required4">Work required</a></h4>
<div class="level4">

<p>
This project involves:
</p>
<ol>
<li class="level1"><div class="li"> Implementation of DRC layer (part of work called out in “DRC Upgrade” section).</div>
</li>
<li class="level1"><div class="li"> Upgrade existing DRC checker with new DRC layer.</div>
</li>
<li class="level1"><div class="li"> Update <acronym title="Graphical User Interface">GUI</acronym> to use upgraded DRC checker.</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup.</div>
</li>
</ol>
<hr />

</div>
<!-- EDIT492 SECTION "Design Rule Checking Upgrade" [26083-29268] -->
<h3 class="sectionedit493"><a name="project_milestones_duration_and_budget_estimates" id="project_milestones_duration_and_budget_estimates">Project milestones, duration, and budget estimates</a></h3>
<div class="level3">

<p>
Although they are intertwined, the major focus areas are scoped independently
here.  Ordinarily, a project manager would put a Gantt chart here, but that
level of detail is probably too fine for the purposes of an open source
project.  Therefore, I simply call out an estimated time required for each
subtask.  The project duration times are SWAGs based upon my limited experience in estimating software projects.  They are based upon 8 hour work days (i.e. this work is performed
as a full-time job) at a nominal billing rate of $50/hour.  <strong>It is up to the developer to
validate these estimations and negotiate his own billing rate before he agrees to perform this work.</strong>
</p>

</div>

<h4><a name="forward_annotation_upgrade1" id="forward_annotation_upgrade1">Forward annotation upgrade</a></h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Determine which actions remain to be scripted so that forward annotation of any board is possible using an action list.  (2 days).</div>
</li>
<li class="level1"><div class="li"> Define syntax for remaining actions, and document full syntax (2 days).  This document will be used to update gsch2pcb (outside the scope of this project).</div>
</li>
<li class="level1"><div class="li"> Write sample action scripts for testing purposes (1 day).</div>
</li>
<li class="level1"><div class="li"> Creating the missing actions required for full forward annotation (3 days).</div>
</li>
<li class="level1"><div class="li"> Creating a method for reading in an action script (2 days)</div>
</li>
<li class="level1"><div class="li"> Integrating the new script-based forward annotation into PCB&#039;s <acronym title="Graphical User Interface">GUI</acronym> (1 day)</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup (5 days).</div>
</li>
</ol>

<p>
Total duration:  16 days = 128 hours.
Cost: $6400
</p>

</div>

<h4><a name="gui_modernization1" id="gui_modernization1">GUI modernization</a></h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Refactoring and upgrade of program internals to support noun/verb actions (5 days)</div>
</li>
<li class="level1"><div class="li"> Create new windows (e.g. object editor, move, rotate, etc.) (5 days).  </div>
</li>
<li class="level1"><div class="li"> Refactoring and upgrade of program internals to support selection modes (5 days).</div>
</li>
<li class="level1"><div class="li"> Implementation of <acronym title="Graphical User Interface">GUI</acronym> resource file which is read in upon program start to configure user interface (3 days).</div>
</li>
<li class="level1"><div class="li"> <acronym title="Graphical User Interface">GUI</acronym> upgrade.  Specifically, hook up the callbacks to the menu items and buttons defined in the <acronym title="Graphical User Interface">GUI</acronym> resource file (3 days).</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup (5 days).</div>
</li>
</ol>

<p>
Total duration: 26 days = 208 hours
Cost: $10400
</p>

</div>

<h4><a name="footprint_editor_implementation1" id="footprint_editor_implementation1">Footprint editor implementation</a></h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Create internal structures and methods needed to support a separate footprint editor (4 days).</div>
</li>
<li class="level1"><div class="li"> Create footprint editing window (if the separate window approach is adopted) (3 days).</div>
</li>
<li class="level1"><div class="li"> Integrate access to footprint editor into main PCB <acronym title="Graphical User Interface">GUI</acronym> (2 days).</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup (5 days).</div>
</li>
</ol>

<p>
Total duration: 14 days = 112 hours.
Cost: $5600
</p>

</div>

<h4><a name="layer_design_object_upgrade" id="layer_design_object_upgrade">Layer/design object upgrade</a></h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Upgrade internal structures and methods to enable full layer support (5 days).</div>
</li>
<li class="level1"><div class="li"> Create layer configuration window (3 days).</div>
</li>
<li class="level1"><div class="li"> Create internal datastructures and methods to support padstacks (4 days).</div>
</li>
<li class="level1"><div class="li"> Create padstack configuration window (3 days).</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup (5 days).</div>
</li>
</ol>

<p>
Total duration: 20 days = 160 hours.
Cost: $8000
</p>

</div>

<h4><a name="design_rule_checking_upgrade1" id="design_rule_checking_upgrade1">Design Rule Checking Upgrade</a></h4>
<div class="level4">
<ol>
<li class="level1"><div class="li"> Implementation of DRC layer (part of work called out in “DRC Upgrade” section) (0 days, assuming layer upgrade is complete).</div>
</li>
<li class="level1"><div class="li"> Upgrade existing DRC checker with new DRC layer (3 days).</div>
</li>
<li class="level1"><div class="li"> Update <acronym title="Graphical User Interface">GUI</acronym> to use upgraded DRC checker (2 days).</div>
</li>
<li class="level1"><div class="li"> Testing and bug cleanup (5 days).</div>
</li>
</ol>

<p>
Total duration: 10 days = 80 hours.
Cost: $4000

</p>

</div>
<!-- EDIT493 SECTION "Project milestones, duration, and budget estimates" [29269-] --></body>
</html>
