@node lepton-schematic, lepton-netlist, Symbols, Top
@chapter Schematic capture
@cindex lepton-schematic
@cindex schematic capture

@menu
* Introduction to lepton-schematic::
* Running lepton-schematic::
* lepton-schematic window::
* Dialog boxes and widgets::
* Creating and opening schematics::
* Editing schematics::
* Working with windows::
* Quitting the program::
* Saving schematic pages::
* Printing and exporting::
* Selecting objects::
* Searching for text::
* Check symbols::
* lepton-schematic command line options::
* Component libraries::
* Interactive work with Scheme code::
@end menu

@node Introduction to lepton-schematic, Running lepton-schematic, lepton-schematic, lepton-schematic
@section Introduction to lepton-schematic
@cindex lepton-schematic, introduction
@cindex introduction to lepton-schematic

@schematic{} is a @dfn{schematic capture} application in the Lepton
toolset.  It is mostly used for interactive creation of electronic
@dfn{schematics} and @dfn{symbols}, though you can do some other
graphical work in it, for example, draw block diagrams.  Schematics
represent electronic circuits, and symbols stand for their logical
blocks such as components or subcircuits.  The connections between the
blocks are represented by @dfn{nets} (wires).  Component symbols can
be obtained either from a standard Lepton @ref{Component libraries, ,
component library}, from some net resources, or created by the user.

After creation, schematics may be printed, converted to several image
formats, including PDF, or exported to several netlist formats for
processing by other tools.

@node Running lepton-schematic, lepton-schematic window, Introduction to lepton-schematic, lepton-schematic
@section Running lepton-schematic
@cindex Running lepton-schematic
@cindex lepton-schematic, running

@schematic{} is a GUI tool, so there are different ways
of running it.  You can launch it from your window manager menu, by
clicking onto an appropriate schematic or symbol icon (@file{.sch} or
@file{.sym}), or from your terminal.  To launch it from menu, look up
for @clicksequence{Development}, @clicksequence{Electronics}, or
@clicksequence{Engineering} submenus.  The last way is most powerful
and versatile.  You can run the command without any arguments just to
open a new, untitled schematic:

@example
lepton-schematic
@end example

or you can specify the names of schematic and symbol files:

@example
lepton-schematic schematic.sch /path/to/symbol.sym
@end example

@schematic{} accepts several @ref{lepton-schematic
command line options, command line options}. Please look the
@code{lepton-schematic(1)} manual page for more information.
Alternatively, run:

@example
lepton-schematic --help
@end example

to get the brief description of all the options supported.

@node lepton-schematic window, Dialog boxes and widgets, Running lepton-schematic, lepton-schematic
@section Main lepton-schematic window
@cindex lepton-schematic window
@cindex main lepton-schematic window
@cindex window, lepton-schematic
@cindex main window, lepton-schematic

The window of @schematic{} consists of the following widgets:

@itemize
@item Menubar
@item Toolbar
@item Tabs notebook
@item Drawing area (Page view)
@item Right dock
@item Bottom dock
@item Context menus
@end itemize

@menu
* Menubar::
* Menu File::
* Menu Edit::
* Menu View::
* Menu Page::
* Menu Add::
* Menu Hierarchy::
* Menu Attributes::
* Menu Options::
* Menu Netlist::
* Menu Help::
@end menu

@node Menubar, Menu File, lepton-schematic window, lepton-schematic window
@subsection Menubar
The Menubar widget contains several menus grouped by actions.

@node Menu File, Menu Edit, Menubar, lepton-schematic window
@subsection Menu File
@cindex menu File

@table @emph
@item New

@clicksequence{File @click{} New} (@kbd{Ctrl-N} or @kbd{F N}) allows
you to create a new untitled schematic page.  The same as
@clicksequence{Page @click{} New}. @xref{Creating and opening
schematics}.

@item Open...

@clicksequence{File @click{} Open...} (@kbd{Ctrl-O} or @kbd{F O})
opens a dialog box for choosing and opening an existing schematic or
symbol file.  @xref{Creating and opening schematics}.

@item Open Recent

@clicksequence{File @click{} Open Recent} (@kbd{F O}) lets you open
one of the recently opened files without the need of searching it in
the file system.

@item Save

@clicksequence{File @click{} Save} (@kbd{F S}) is used to save changes
in your schematic page on disk.  @xref{Saving schematic pages}.

@item Save As...

@clicksequence{File @click{} Save As...} (@kbd{F A}) allows you to
save the page you edit under another name.

@item Save all

@clicksequence{File @click{} Save all} (@kbd{F L}) saves all
unsaved pages.  Anything specified above about the Save diallog
matters here as well.  You should only note that the Save As dialog is
opened for each of untitled pages.

@item Print...

@clicksequence{File @click{} Print...} (@kbd{F P} or @kbd{Ctrl-P})
opens a standard GTK printing dialog in which you can preview and
print schematics.  @xref{Printing and exporting}.

@item Write Image...

@clicksequence{File @click{} Write Image...} (@kbd{F I}) can be used
to export schematic and symbol pages as images.  @xref{Printing and
exporting}.

@item Invoke macro...

@clicksequence{File @click{} Invoke macro...} (@kbd{:}, colon, or
@kbd{E Shift-:}) allows you to execute some small excerpts of Scheme
code interactively in GUI.  @xref{Interactive work with Scheme code}.

@item Execute Script...

@clicksequence{File @click{} Execute Script...} (@kbd{F T}) allows you
to execute a Scheme script file stored in your file system.
@xref{Interactive work with Scheme code}.

@item REPL...

@clicksequence{File @click{} REPL...} (@kbd{F Shift-R}) lets you hack
your Scheme extensions interactively, using the REPL in the background
terminal where you started @schematic.  @xref{Interactive work with
Scheme code}.

@item New Window

@clicksequence{File @click{} New Window} (@kbd{F W}) allows you to
open a new @emph{window} of @schematic{}.  @xref{Working with windows}.

@item Close Window

@clicksequence{File @click{} Close Window} (@kbd{F C}) closes the
current @schematic{} window.  @xref{Working with windows}.

@item Quit

@clicksequence{File @click{} Quit} (@kbd{F Q} or @kbd{Alt-Q}) closes
all open windows of @schematic{}.  @xref{Quitting the program}.

@end table

@node Menu Edit, Menu View, Menu File, lepton-schematic window
@subsection Menu Edit
@cindex menu Edit

@table @emph
@item Undo

@clicksequence{Edit @click{} Undo} (@kbd{Ctrl-Z}, @kbd{U},
@kbd{Shift-U}, or @kbd{E Shift-U}) undoes the last editing action.
@xref{Editing schematics}.

@item Redo

@clicksequence{Edit @click{} Redo} (@kbd{Shift-Ctrl-Z}, @kbd{Ctrl-Y},
@kbd{Shift-R}, or @kbd{E Shift-R}) repeats recently undone actions.
@xref{Editing schematics}.

@item Cut

@clicksequence{Edit @click{} Cut} (@kbd{Ctrl-X}) cuts currently
selected objects to clipboard.  @xref{Editing schematics}.

@item Copy

@clicksequence{Edit @click{} Copy} (@kbd{Ctrl-C}) copies
currently selected objects to clipboard.  @xref{Editing schematics}.

@item Paste

@clicksequence{Edit @click{} Paste} (@kbd{Ctrl-V}) allows to paste the
current clipboard contents to the drawing area.  @xref{Editing
schematics}.

@item Delete

@clicksequence{Edit @click{} Delete} (@kbd{Delete}, @kbd{D}, or @kbd{E
D}) deletes currently selected objects.  @xref{Editing schematics}.

@item Select Mode
@clicksequence{Edit @click{} Select Mode} (@kbd{S} or @kbd{E S})
switches on the selection mode.  @xref{Selecting objects}.

@item Select All

@clicksequence{Edit @click{} Select All} (@kbd{Ctrl-A}) selects all
non-locked objects on a page.  @xref{Selecting objects}.

@item Deselect

@clicksequence{Edit @click{} Deselect} (@kbd{Shift-Ctrl-A}) deselects
all selected objects, if any.  @xref{Selecting objects}.

@item Copy Mode

@clicksequence{Edit @click{} Copy Mode} (@kbd{C} or @kbd{E C}) allows
one-time copy of selected objects.  @xref{Editing schematics}.

@item Multiple Copy Mode

@clicksequence{Edit @click{} Multiple Copy Mode} (@kbd{E Y}) allows to
make several copies of the same objects.  @xref{Editing schematics}.

@item Move Mode

@clicksequence{Edit @click{} Move Mode} (@kbd{M} or @kbd{E M}) allows
you to move selected objects without depressing the left mouse button.
@xref{Editing schematics}.

@item Rotate 90 Mode

@clicksequence{Edit @click{} Rotate 90 Mode} (@kbd{E R}) rotates
selected objects by 90 degrees counter-clockwise each time.
@xref{Editing schematics}.

@item Mirror Mode
@clicksequence{Edit @click{} Mirror mode} (@kbd{E I}) is used to
mirror objects around the X axis.  @xref{Editing schematics}.

@item Object Properties...
@clicksequence{Edit @click{} Object Properties...} (@kbd{E O}) opens a
dialog where you can see and change the properties of primitive
objects.  @xref{Editing schematics}.

@item Edit...
@clicksequence{Edit @click{} Edit...} (@kbd{E E}) opens one of the
editing dialogs, @emph{Edit Attributes}, @emph{Edit Attribute}, or
@emph{Edit Text}, depending on what objects are selected.
@xref{Editing schematics}.

@item Edit Text...
@clicksequence{Edit @click{} Edit Text...} (@kbd{E X}) opens the Edit
Text dialog box for editing plain text objects.  @xref{Editing
schematics}.

@item Slot...
@clicksequence{Edit @click{} Slot...} (@kbd{E Shift-S}) is used to
change slot number of a slotted component.  @xref{Editing schematics}.

@item Lock
@clicksequence{Edit @click{} Lock} (@kbd{E L}) locks selected objects,
that is, makes them not selectable by just clicking on them.
@xref{Editing schematics}.

@item Unlock
@clicksequence{Edit @click{} Unlock} (@kbd{E Shift-L}) unlocks
selected locked objects.  @xref{Editing schematics}.

@item Embed Component/Picture
@clicksequence{Edit @click{} Embed Component/Picture} (@kbd{E B})
embeds a component or a picture into schematic.  @xref{Editing
schematics}.

@item Unembed Component/Picture
@clicksequence{Edit @click{} Unembed Component/Picture} (@kbd{E
Shift-B}) unembeds an embedded component or a picture from schematic.
@xref{Editing schematics}.

@item Update Component
@clicksequence{Edit @click{} Update Component} (@kbd{E U}) updates
selected components if they changed before.  @xref{Editing
schematics}.

@item Symbol Translate...
@clicksequence{Edit @click{} Symbol Translate...} (@kbd{E T})
translates a symbol being edited to origin.  @xref{Editing
schematics}.

@end table

@node Menu View, Menu Page, Menu Edit, lepton-schematic window
@subsection Menu View
@cindex menu View

@table @emph
@item Side Dock
@clicksequence{View @click{} Side Dock} (@kbd{V A}) opens the side
dock widget with three tabs: ``Object'', ``Text'', and ``Options''.
You can select the tabs with left mouse click, or by choosing one of
the actions @clicksequence{Edit @click{} Edit...} (@kbd{E E}),
@clicksequence{Edit @click{} Edit Text...} (@kbd{E X}), or
@clicksequence{Options @click{} Options...} (@kbd{E X})
correspondingly.  See the description of corresponding menu items for
more information on that.  The action is available if displaying dock
widgets is enabled in @ref{use-docks, configuration}.

@item Bottom Dock
@clicksequence{View @click{} Bottom Dock} (@kbd{V S}) opens the bottom
dock widget with two tabs: ``Find Text'' and ``Log''.  The action is
available if showing dock widgets is enabled in @ref{use-docks,
configuration}.

@item Find Text Results
@clicksequence{View @click{} Find Text Results} opens a widget with
results of last text searching.  If the docks are enabled in
@ref{use-docks, configuration}, the widget is displayed in the bottom
dock.  Otherwise, a separate dialog window is open.  @xref{Searching
for text}.

@item Redraw
@clicksequence{View @click{} Redraw} (@kbd{R} or @kbd{V R}) allows you
to trigger redrawing of the current page if, for example, you see some
rendering glitches on the canvas, or the file has been changed by some
external program such as, for example, @command{lepton-refdes_renum}.

@item Pan
@clicksequence{View @click{} Pan} (@kbd{X} or @kbd{V P}) pans the
page, that is, makes it appear so the current mouse cursor position in
world coordinates becomes the center of the view.

@item Zoom Box
@clicksequence{View @click{} Zoom Box} (@kbd{W} or @kbd{V B}) zooms
the view to coordinates defined by a box you draw on the canvas.  The
first coordinate of the box is the current mouse position.  Move the
mouse to another point and click to set the second coordinate.  The
view will be scaled so the box region wholly fits in the canvas.

@item Zoom Extents
@item Zoom In
@item Zoom Out
@item Zoom Full
@item Dark Color Scheme
@item Light Color Scheme
@item BW Color Scheme
@item Color Scheme Editor...
@end table

@node Menu Page, Menu Add, Menu View, lepton-schematic window
@subsection Menu Page
@cindex menu Page

@table @emph
@item Manager...
@item Previous
@item Next
@item Close
@item Revert...
@item Next Tab
@item Previous Tab
@end table

@node Menu Add, Menu Hierarchy, Menu Page, lepton-schematic window
@subsection Menu Add
@cindex menu Add

@table @emph
@item Component...
@item Net
@item Bus
@item Attribute...
@item Text...
@item Line
@item Path
@item Box
@item Circle
@item Arc
@item Pin
@item Picture...
@end table

@node Menu Hierarchy, Menu Attributes, Menu Add, lepton-schematic window
@subsection Menu Hierarchy
@cindex menu Hierarchy

@table @emph
@item Up
@item Down Schematic
@item Down Symbol
@end table

@node Menu Attributes, Menu Options, Menu Hierarchy, lepton-schematic window
@subsection Menu Attributes
@cindex menu Attributes

@table @emph
@item Attach
@item Detach
@item Show Value
@item Show Name
@item Show Both
@item Toggle Visibility
@item Hide Specific Text...
@item Show Specific Text...
@item Show/Hide Hidden Text
@item Find Text/Check Symbol
@item Autonumber Text...
@end table

@node Menu Options, Menu Netlist, Menu Attributes, lepton-schematic window
@subsection Menu Options
@cindex menu Options

@table @emph
@item Options...
@item Font...
@item Grid +
@item Grid -
@item Grid Style: Cycle Dots/Mesh/Off
@item Grid Snap: Cycle Grid/Resnap/Off
@item Grips: On/Off
@item Feedback Mode: Outline/Box
@item Net: Rubberband On/Off
@item Net: Magnetic On/Off
@item Coord Window
@item Log Window
@end table

@node Menu Netlist, Menu Help, Menu Options, lepton-schematic window
@subsection Menu Netlist
@cindex menu Netlist

Currently, the menu consist of an only item demonstrating the
possibility to run Lepton netlisting code in GUI.

@table @emph
@item 1 allegro
Produce Allegro netlist.  The output will go to the file
@file{allegro.out} in the current working directory.  @xref{Allegro
backend} for more.
@end table

@node Menu Help,  , Menu Netlist, lepton-schematic window
@subsection Menu Help
@cindex menu Help

@table @emph
@item Lepton EDA Reference Manual

@clicksequence{Help @click{} Lepton EDA Reference Manual} (@kbd{H M})
will open the manual you're reading just now in your HTML browser.

@item gEDA Wiki Documentation

@clicksequence{Help @click{} gEDA Wiki Documentation} (@kbd{H W}) will
open the documentation page of the legacy gEDA wiki in your HTML
browser.  It may still be helpful in some cases.

@item Find Component Documentation

@clicksequence{Help @click{} Find Component Documentation} (@kbd{H C}
or @kbd{H O}) tries hard to find any documentation for the first
component amongst selected objects.  If no component is selected, the
action is unavailable.

@item Hotkeys...

@clicksequence{Help @click{} Hotkeys...} (@kbd{H H}) may be used to
look up for some action you do not know shortcut for.  It displays a
dialog with all action menu names and their corresponding hotkeys.

@item About

@clicksequence{Help @click{} About} (@kbd{H A}) opens the standard GTK
About dialog with some useful information on @schematic.

@end table


@node Dialog boxes and widgets, Creating and opening schematics, lepton-schematic window, lepton-schematic
@section Dialog boxes and widgets
@cindex dialog boxes
@cindex dialog box

@menu
* Add Component widget::
* Save As dialog box::
* Log window::
* Macro widget::
@end menu

@node Add Component widget, Save As dialog box, Dialog boxes and widgets, Dialog boxes and widgets
@subsection Add Component widget
@cindex add component widget
@cindex add component dialog box

@node Save As dialog box, Log window, Add Component widget, Dialog boxes and widgets
@subsection Save As dialog box
@cindex save as
@cindex save as dialog box
@cindex dialog boxes, save as

@node Log window, Macro widget, Save As dialog box, Dialog boxes and widgets
@subsection Log window
@cindex log window
@cindex log widget

In the log window you'll find important, and sometimes not, messages
about the work and errors of @schematic{}.  At least, the developers
tried hard to output anything useful and interesting.  Please report
if you think we need to output anything other there.
@xref{Communication} on how to get in touch with us.

First when you run the program, the log window contains information
about the program version, about what RC files have been loaded, and
what schematic files have been opened.  You can configure the opening
of log window at start-up of the program, though by default it won't
be open to not make the users nervous.  There are other related
configuration settings that you may count useful.
@xref{Configuration} for more.  Then, when you start working, the log
window contains other useful info related to your work.  Open the
window if it seems something to work wrong, maybe you'll find a hint
there.  In the log window you can also watch the output of macro
commands you entered in the macro widget.  @xref{Macro widget} for
more info on this.  There can be also another information about some
long running procedures.  For example, about netlist creation or about
the work of third-party utilities you launched via a Scheme extension.

If your program crashed and, oddly, the log window is for some reason
missing after that, you will still be able to look into the log files.
@xref{Logging} for more info on the files.

If @ref{use-docks, , docks} are enabled in your configuration, the Log
widget will be shown as the second tab in the bottom dock.  Otherwise,
a separate Log window will be opened.


@node Macro widget,  , Log window, Dialog boxes and widgets
@subsection Macro widget
@cindex macro widget

@node Creating and opening schematics, Editing schematics, Dialog boxes and widgets, lepton-schematic
@section Creating new and opening existing schematic files
@cindex creating schematics
@cindex create schematics
@cindex create schematic
@cindex create schematic files
@cindex create schematic file
@cindex schematic creation
@cindex opening schematics
@cindex opening schematic
@cindex opening schematic file
@cindex open schematics
@cindex open schematic
@cindex open schematic file

Every time you launch @schematic{} without arguments in a terminal, or
from your window manager menu, a new untitled schematic page is
created.  Use @clicksequence{File @click{} New} within @schematic{} if
you want to create another page.

The default page name for new pages is formed as a filename prefix
defined in the configuration key @ref{default-filename} and a serial
number which is incremented every time a new page is created,
e.g. @file{untitled_3.sch}.  Usually, a title block symbol is
inserted, @pxref{Title block symbol}.

Within the program, you can open an already existing schematic using
the menu action @clicksequence{File @click{} Open...}  In the opened
dialog box select the file you need and click the button @samp{Open}
to actually open it, or @samp{Cancel} to cancel with it.  At the
bottom-right of the dialog there is a filter button.  With it, you can
change view to see schematics or symbols only, both schematics and
symbols, or any files in case you want to look at some other stuff in
the selected directory.

If you want to open a file you worked on recently, click the menu item
@clicksequence{File @click{} Open Recent}.  The submenu contains
several file names.  You can configure how many files should be shown
there using the configuration key @ref{max-recent-files}.


@node Editing schematics, Working with windows, Creating and opening schematics, lepton-schematic
@section Editing schematics
@cindex editing schematics
@cindex edit schematics
@cindex schematic, edit
@cindex schematic, editing

In order to do any action on some object, you have to select it first.
@xref{Selecting objects} if you don't know how to do it.

When editing schematics, you can undo and redo several last actions
using @clicksequence{Edit @click{} Undo} (@kbd{Ctrl-Z}, @kbd{U},
@kbd{Shift-U}, or @kbd{E Shift-U}) and @clicksequence{Edit @click{}
Redo} (@kbd{Shift-Ctrl-Z}, @kbd{Ctrl-Y}, @kbd{Shift-R}, or @kbd{E
Shift-R}).  The latter restores the results of the last editing action
undone with @clicksequence{Edit @click{} Undo}.  The number of
possible actions for undo/redo is limited in the configuration setting
@ref{undo-levels}.

If you need to copy some objects, select them and do
@clicksequence{Edit @click{} Copy Mode} (@kbd{C} or @kbd{E C}).  The
objects will be visually duplicated and you will be able to put the
copies where you need to by left-clicking on the canvas.  This allows
one-time copy of the objects.  Another option is copying objects
multiple times.  Select @clicksequence{Edit @click{} Multiple Copy
Mode} or hit @kbd{E Y} to switch on the mode.  Use left-click to
insert the objects.  Unlike the former case, copying won't stop after
first insertion.  Click once again, and a new copy will be made.  The
copying process can be stopped by switching to some other mode, for
example, by hitting @kbd{Esc} to choose the select mode, or by
clicking at the net mode button in the toolbar.  In both cases (one or
multiple copies), the current selection does not change during the
process.

The objects on canvas can also be copied or cut to clipboard, and
pasted from it using @clicksequence{Edit @click{} Copy}
(@kbd{Ctrl-C}), @clicksequence{Edit @click{} Cut} (@kbd{Ctrl-X}),
@clicksequence{Edit @click{} Paste} (@kbd{Ctrl-V}) correspondingly.
To delete all currently selected objects use @clicksequence{Edit
@click{} Delete} (@kbd{Delete}, @kbd{D}, or @kbd{E D}).  If some of the
objects are locked, the dialog prompting for deletion of all selected
objects or only unlocked ones will appear, in which you can also
cancel the deletion.

You can move objects on the canvas using the left mouse button: click
on the object you want to move, keep the button depressed, drag the
object where you need to and release the button to place the object.
The object gets selected after the operation.  If you select several
objects beforehand, the same operation allows you to move and place
them all.  Sometimes it is more convenient to switch on move mode to
move objects without depressing the mouse button.  Select
@clicksequence{Edit @click{} Move Mode} (@kbd{M} or @kbd{E M}) and
move the selected objects where you want to, then use left click once
to place them on the canvas.

@clicksequence{Edit @click{} Rotate 90 Mode} (@kbd{E R}) rotates
selected objects by 90 degrees counter-clockwise each time.  The
objects are rotated around the mouse cursor.

@clicksequence{Edit @click{} Mirror mode} (@kbd{E I}) can be used to
mirror objects such as components and pictures around the X axis.
Mirroring of other, simple objects is supported as well, though it's
rarely useful.  Mirroring around the Y axis is not yet supported.
However, you can use a sequence of mirrorings and rotations as a
workaround to get the look you want.

You can also rotate or mirror objects while moving them, using one of
the ways described above, or when inserting a component.

@clicksequence{Edit @click{} Object Properties...} (@kbd{E O}) opens a
dialog where you can see and change the properties of primitives such
as lines, boxes, pins, text and so on.  The editable properties
include color, stroke and filling styles, and the type of pins.
Changing of a property affects all objects selected if they support
it.

If @ref{use-docks, , docks} are enabled in your configuration, the
properties widget will be shown as the first tab in the right dock.

@clicksequence{Edit @click{} Rotate 90 Mode} (@kbd{E R}) rotates
selected objects by 90 degrees counter-clockwise each time.  The
objects are rotated around the mouse cursor.

You can also rotate or mirror objects while moving them, using one of
the ways described above, or when inserting a component.

Apart from editing properties of primitive objects for which the
@emph{Object Properties...} dialog described above is used, you can
edit text contents of text objects such as plain text and attributes.
Use @clicksequence{Edit @click{} Edit...} (@kbd{E E}) to start editing
text objects.  Depending on what objects are selected, one of the
following dialogs will be opened.  @emph{Edit Attributes} dialog is
opened for connectible objects which include components, pins, nets,
and buses.  For non-connectible graphical primitives such as lines,
boxes, etc. the action does nothing.  For plain attributes, the
command opens the @emph{Edit Attribute} dialog (please note the
singular @emph{Attribute} instead of plural @emph{Attributes} in the
former case).  In the dialog you can select and change attribute
names, values, and visibility.  For plain text objects, the command
opens the @emph{Edit Text} dialog the same way as if you would use by
@clicksequence{Edit @click{} Edit Text...}.  If selected objects
include a mixed set of plain text objects, attributes, and connectible
objects, the program opens the dialog appropriate for the objects
selected first so you may end up with not what you really wanted.  In
such a case, deselect objects, select wanted ones, and try again.

The action @clicksequence{Edit @click{} Edit Text...} (@kbd{E X}) and
the @emph{Edit Text} dialog box it invokes is intended for editing
plain text objects.  Thus, unlike the attribute editing dialogs, this
dialog displays attributes as strings in the form ``name=value''.

If @ref{use-docks, , docks} are enabled in your configuration, the
@emph{Edit Text} widget will be shown as the second tab in the right
dock.

Sometimes a symbol may represent components with different pin numbers
without changing it in any other aspect.  For example, quad-opamp has
four same opamps in one package for which only pin numbers differ on
schematic page.  Such components are called @emph{slotted} and there
is a special action in @schematic{} to change the slot number quickly.
Use @clicksequence{Edit @click{} Slot...} (@kbd{E Shift-S}) and enter
the slot number you want.  It should be greater than zero but not
greater than the value stored in the ``numslot'' attribute of the
symbol.  While you can attach the ``slot'' attribute to any object on
the page, slots are useless for graphical primitives, text, and
pictures, and are only meaningful for such slotted components.  While
you can use the attribute for non-slotted components, it won't add
much to your schematics unless you change the component symbol to
support slots by adding both ``numslots'' attribute and ``slotdef''
attributes which determine how many slots will be used at all and what
pin numbers will be used for each particular slot.

Sometimes you want some objects on the page to not get in your way
while editing schematics.  It is particularly true for big symbols
like title blocks (@pxref{Title block symbol}).  Such symbols are
intentionally put to background and other symbols are placed over
them.  The issue here is the selection mechanism of @schematic{}.
When you click on an object to select it, and there are several
selectable objects under the mouse cursor, the program will select
each of them one by one to let you choose the wanted one.  Locked
symbols are to be excluded from such a sequence since it would be
annoying to, say, every time select the title block symbol when you
merely want to select any other object within it.  Select symbols you
want to be locked and use @clicksequence{Edit @click{} Lock} (@kbd{E
L}) to lock them.  (By the way, you rarely need this for title blocks
as they usually are added as already locked when a new schematic is
created.  @xref{Title block symbol} for more information.)  In order
to unlock a symbol, select it using box selection (@pxref{Box
selection}) and use @clicksequence{Edit @click{} Unlock} (@kbd{E
Shift-L}).

@quotation Note
Locking and unlocking actions affect not only components but also all
the attributes attached to them.  You don't have to select each one of
them individually, it is sufficient to select just the component they
are attached to.
@end quotation

@quotation Note
Primitive objects (not components) cannot be locked or unlocked, it is
not supported in the current file format (@pxref{gEDA file format}).
However, a Scheme extension may be used in Lepton to achieve that.
@end quotation

There are two special actions that allow you to save data of a
component or a picture within schematic or undo such a change.
@clicksequence{Edit @click{} Embed Component/Picture} (@kbd{E B})
embeds the data of selected component or picture into schematic.  This
may make sense in case you want to distribute your schematic as one
file and/or prevent data loss or corruption due to different set of
symbols available at the target and destination locations.  Currently,
you have to embed each component or picture instance if you have
several of them in your schematic.  Otherwise, not embedded objects
won't be present in the schematic if you don't include libraries with
appropriate symbols into your project.  This is limitation of the
current file format.  @xref{gEDA file format} for more information.
Embedding objects makes thus the file size bigger (sometimes, much
bigger), and after you made sure anything is OK, and necessary symbols
or pictures are in place, you may want to unembed the objects.  The
action @clicksequence{Edit @click{} Unembed Component/Picture} (@kbd{E
Shift-B}) does just that.  It unembeds a component or picture embedded
by the menu item action described above.  Note that the command will
be ignored if you don't have the symbol or image corresponding to your
unembeddable object in one of the libraries available for your
schematic.  Remember to open the log window and see what could went
wrong if your schematic file did not change after this action and
saving it.

If you edit a symbol and save it, schematics containing it are not
updated automatically.  You have to update component instances
manually.  Select the components you want to update and use
@clicksequence{Edit @click{} Update Component} (@kbd{E U}) to actually
do it.

Another useful action is translation of the page contents to origin,
that is, to the coordinate (0, 0) of the page.  It is usually
necessary when you create or edit a symbol.  The origin defines the
anchor of the symbol.  When you insert the symbol from the component
library, this point in the symbol corresponds to the position of the
mouse cursor, so the visible contents of your component will be
positioned around the mouse cursor at the same distance the contents
of the corresponding symbol is positioned around the origin within it.
Usually, it is the left-bottom point of a symbol.  However you can
define it anywhere. If you want, for example, the anchor to be located
at the center of your symbol, move the symbol contents to lay around
the origin.  Use @clicksequence{Edit @click{} Symbol Translate...}
(@kbd{E T}) to translate the symbol you edit to origin and then place
its contents the way you wish.

@quotation Note
If the contents of your symbol is too far from origin, you may even
not see the symbol when inserting.  Zoom out to see if this is the
case then.
@end quotation


@node Working with windows, Quitting the program, Editing schematics, lepton-schematic
@section Working with windows
@cindex lepton-schematic windows
@cindex working with windows
@cindex open new window
@cindex close window

You can open new and close existing @schematic{} windows.  Schematic
data may be exchanged between the windows using system clipboard.

@clicksequence{File @click{} New Window} (@kbd{F W}) allows you to
open a new @emph{window} of @schematic{} (not a @emph{page}).  In that
window you can work with different pages and different configuration
settings.

@clicksequence{File @click{} Close Window} (@kbd{F C}) closes the
currently active @schematic{} window (the window where you use this
shortcut) with all its pages.  The @emph{Save File} dialog box will be
open for every unsaved page. @xref{Saving schematic pages}.

@node Quitting the program, Saving schematic pages, Working with windows, lepton-schematic
@section Quitting the program
@cindex exit lepton-schematic
@cindex lepton-schematic, exit
@cindex quit lepton-schematic
@cindex lepton-schematic, quit
@cindex quitting lepton-schematic

@clicksequence{File @click{} Quit} (@kbd{F Q} or @kbd{Alt-Q}) closes
all open windows of @schematic{} stemming from the same root window
with all their pages.  It won't close those windows you've launched in
a different instance (from a terminal, from your window manager menu,
etc.).  The @emph{Save File} dialog will be opened for every unsaved
page. @xref{Saving schematic pages}.

@node Saving schematic pages, Printing and exporting, Quitting the program, lepton-schematic
@section Saving schematic pages
@cindex save
@cindex save pages
@cindex save schematic pages
@cindex save schematics
@cindex saving
@cindex saving pages
@cindex saving schematic pages
@cindex saving schematics
@cindex schematic, save

Use @clicksequence{File @click{} Save} or the @kbd{F S} keyboard
shortcut to save your modified schematic page.  Do it frequently to
not lose your design.  Unsaved pages are marked with an asterisk
before their names in window titles and with little @samp{Save}
buttons on tabs they are open in.

Use @clicksequence{File @click{} Save As...} or the @kbd{F A} if you
want to save your file under another name.  In such a case, the
@emph{Save As} dialog box will be opened prompting you to input the
file name you want.  The same dialog will be opened automatically if
you save a newly added and not yet saved untitled page.  @xref{Save As
dialog box}.

Like in the @emph{File Open} dialog, you can use the filter entry
below and choose the file type you need: schematics, symbols,
schematic and symbols, or any files.  Two first options change the
saved file extension as well.

@node Printing and exporting, Selecting objects, Saving schematic pages, lepton-schematic
@section Printing and exporting schematics
@cindex printing schematics
@cindex exporting schematics

@clicksequence{File @click{} Print...} (@kbd{F P} or @kbd{Ctrl+P})
will open a standard GTK printing dialog.  Choose your print
destination, a file to print to, or a printer, change printing
settings if needed and go ahead.  If you print to a file, you can
choose the file format, e.g. PDF or PostScript.  The button
@samp{Print Preview} lets you see the preview of your page when it is
printed.

@quotation Note
GTK2 and GTK3 standard printing dialogs may support different output
formats.
@end quotation

@quotation Note
You can also output PDF with the @clicksequence{File @click{} Write
Image...} menu (see below) or export your schematics and symbols with
the @cli{} command (@pxref{lepton-cli export}).
@end quotation

@clicksequence{File @click{} Write Image...} (@kbd{F I}) is used for
exporting schematic and symbol pages as images.  In the export dialog
box you can choose one of several supported image format options,
including PDF, as well as one of predefined size of the image, and
whether the image should be colored or black-and-white.  The sizes are
not relevant for PDF files, those will be sized to fit the visible
contents of your schematic or symbol page.  The @cli{} utility allows
more accurate control of the image properties so if you want to set
some custom options, please use it (@pxref{lepton-cli export}).

@node Selecting objects, Searching for text, Printing and exporting, lepton-schematic
@section Selecting objects
@cindex selecting objects
@cindex object selection

Selecting objects is necessary to make any action on them, for
instance, moving, copying, or changing their size.  Selected objects
are highlighted so you can visually distinguish them from unselected
ones.

@menu
* Simple object selection::
* Box selection::
* Selecting and deselecting all objects::
@end menu

@node Simple object selection, Box selection, Selecting objects, Selecting objects
@subsection Simple object selection
@cindex simple object selection

@clicksequence{Edit @click{} Select Mode} (@kbd{S} or @kbd{E S})
switches on the selection mode.  All unfinished actions are rejected
as well as all unfinished object changes.  If you just started a
primitive object creation, it will be rejected as well.  In the mode
you may select object by clicking at them using the left mouse button,
or by selection box.  Selected objects are always rendered in the
selection color so you can easily distinguish them from all other
objects.  You cannot select locked objects this way.  They can only be
selected by selection box.  Hitting @key{Ctrl} will toggle the
selection state of the objects you are clicking at or selecting by
selection box, while hitting @key{Shift} in the same situation will
always add objects to the selection.

@node Box selection, Selecting and deselecting all objects, Simple object selection, Selecting objects
@subsection Box selection
@cindex box selection
@cindex selection box

As it is stated in the previous section, sometimes you cannot (or it
is not easy to) select some object.  That is what box selection is
convenient for.  Deselect first all selected objects if there are
any: left-click at some empty place on the canvas.  Zoom your page in
our out so you see any object you want to select.  Left-click and drag
the mouse with the left button depressed so you will see a box that
starts with the point you clicked first and increases or decreases
while you drag the mouse.  Drag the mouse so the objects you want are
within the selection box and release the mouse button.

@node Selecting and deselecting all objects,  , Box selection, Selecting objects
@subsection Selecting and deselecting all objects
@cindex select all
@cindex deselect all

@clicksequence{Edit @click{} Select All} (@kbd{Ctrl-A}) selects all
non-locked objects on a page while @clicksequence{Edit @click{}
Deselect} (@kbd{Shift-Ctrl-A}) deselects all selected objects, if any.
The latter can be achieved by just left mouse click at some free
space of schematic.


@node Searching for text, Check symbols, Selecting objects, lepton-schematic
@section Searching for specific text
@cindex search text
@cindex searching for text
@cindex search attributes
@cindex searching for attributes

Sometimes you would like to find some objects having specific
attributes attached to them, or just want to find and amend some text
object on a large page.

Click on the menu item @clicksequence{Attributes @click{} Find
Text/Check Symbol...} or just use the shortcut @kbd{T F} to open the
text search widget at the bottom of the window.

At the left hand side of the widget, there is a select button with
which you can select one of the different strategies for searching.
The following options are available:

@itemize
@item Find Text:
With this option, you can look up for text by specifying a substring
which will be searched for as is.
@item Find Pattern:
This is a bit more sophisticated way to search for text.  Strings are
matched against a pattern containing @samp{*} and @samp{?} wildcards:
@samp{*} matches an arbitrary, possibly empty, string, and @samp{?}
matches an arbitrary character.  Note that the wildcards @samp{*} and
@samp{?} can not be escaped to include them literally in a pattern.
@item Find Regex:
This is the most powerful way of searching for text as all regular
expressions are available for searching.
@item Check Symbol:
This option is unlike others as it aims to search for all wrong
objects on a symbol page including, but not limited by, text objects.
For this reason, it is described in a dedicated section.  @xref{Check
symbols}.
@end itemize

Enter the text in the text entry and click the button @samp{Find} to
start searching or @samp{Cancel} to dismiss it.  If the @samp{descend
into hierarchy} checkbox is activated, the search will be done in all
the schematic hierarchy.

The results of the last search are stored in memory and you may
quickly return to them by using @clicksequence{View @click{} Find Text
Results}.


@node Check symbols, lepton-schematic command line options, Searching for text, lepton-schematic
@section Interactive checking of symbol contents
@cindex check symbol
@cindex interactive symbol checking

As described in @ref{Searching for text}, you can use
@clicksequence{Attributes @click{} Find Text/Check Symbol...} to look
up for specific text.  It opens the text search widget at the bottom
of the window.  If you click on the option button at the left hand
side of the widget and select the option @samp{Check Symbol:}, you'll
be able to check the symbol page you work with almost the same way as
you would do it with @symcheck{} though in the interactive mode.
Choosing the option hides widget's text entry and only two buttons,
@samp{Find} and @samp{Cancel}, are available then.  Clicking on
@samp{Cancel} closes the widget.  Hit the @samp{Find} button and
@schematic{} will check your page and open a dialog window with
results of the check.  After looking at the issues found and hitting
@samp{OK}, a new window will be opened where your can select and zoom
on any problematic object on the page.


@node lepton-schematic command line options, Component libraries, Check symbols, lepton-schematic
@section lepton-schematic command line options
@cindex lepton-schematic command line options
@cindex lepton-schematic, command-line
@cindex command line options, lepton-schematic


@node Component libraries, Interactive work with Scheme code, lepton-schematic command line options, lepton-schematic
@section Component libraries
@cindex component libraries

The global @emph{component library} of a project is made up of a
number of @emph{symbol libraries}, otherwise named @emph{component
resources}, each of which in turn makes available a number of
component @emph{symbols}.  Each resource may be either a directory on
disk containing symbol files, a command in the system @env{PATH} which
can generate symbol data (e.g. from a database), or a Scheme function
which can do likewise.

The component library system in Lepton manages component resources and
symbols, and abstracts the interface to the underlying storage.  The
libraries are used by all Lepton tools based on the code of the
@code{liblepton} library.

A directory which contains one or more symbol files in @ref{gEDA file
format} may be used as a component resource.  Each symbol file should
have a filename ending in @samp{.sym} (case insensitive).  A component
resource based on a directory can be added using the functions
@ref{component-library} or @ref{component-library-search}.  Symbol
files with filenames starting with a period @samp{.} are ignored.

An executable program in the system search path may be used as a
component resource.  A component resource based on a command may
be added using the function @ref{component-library-command}.

Scheme functions may be used as a component resource as well.  A
component resource based on Scheme functions may be added using the
function @ref{component-library-funcs}.

Each symbol is identified by its @emph{name}, which is stored in the
saved schematic file.  The name must be a valid for storage in a
Lepton schematic file as the @emph{basename} of a @emph{component} object.
For symbols from directory resources, the filename of the symbol is
taken as the symbol name.  For a command resource, the name may be any
permissible string.  Guidelines to follow:

@itemize
@item
Do not begin a symbol name with @samp{EMBEDDED}.
@item
Do not use whitespace, or any of the characters @samp{/:!*?}.
@item
Try to use unique names.
@end itemize


@menu
* Component library setup::
@end menu

@node Component library setup,  , Component libraries, Component libraries
@subsection Component library setup

Component library functions are Scheme procedures that should be
specified in one of @file{gafrc} files.  @xref{Legacy configuration}
for more information.

Environment variables are expanded in all component library functions
working with paths.  You can use, e.g. @samp{$@{HOME@}/lib/path} to
specify the directory you need.  You may form the path names with any
Scheme functions available as well.

The following commands are available:

@menu
* component-library::
* component-library-search::
* component-library-command::
* component-library-funcs::
* reset-component-library::
@end menu

@node component-library, component-library-search, Component library setup, Component library setup
@subsubsection component-library
@cindex component-library

The function @code{component-library} defines a directory containing
@emph{symbol} files as a component resource.  You should use it as
follows:

@lisp
(component-library path)
@end lisp
@noindent
or
@lisp
(component-library path name)
@end lisp

@var{path} is a path to the directory you want to add as a component
resource.  Environment variables in @var{path} are expanded.  Using
this function is convenient if you want each of your library to have a
unique descriptive name.  It can be specified with the second argument
@var{name}.  The name is optional, if it is omitted, @var{path} is
used instead.  The name will be displayed in the @samp{Select
component} window of @schematic.  Obviously, it is
useless for CLI Lepton tools.


@node component-library-search, component-library-command, component-library, Component library setup
@subsubsection component-library-search
@cindex component-library-search

The function @code{component-library-search} is similar to
@ref{component-library} as it also defines a component resource from a
directory on disk.  However, it adds all the directories in it
recursively as a tree of several component resources.  This approach
is good when you don't want to list each separate subdirectory in the
root directory.  But then you won't be able to specify unique names
for the subdirectories.

The usage is as follows:

@lisp
(component-library-search path)
@end lisp
@noindent
or
@lisp
(component-library-search path prefix)
@end lisp

Here @var{path} is a root directory from which you want to make a tree
of component resources.  If optional @var{prefix} is specified, it
will be prepended to the names of the new libraries.


@node component-library-command, component-library-funcs, component-library-search, Component library setup
@subsubsection component-library-command
@cindex component-library-command

A program or set of programs can be used as a component resource.  The
procedure used to add such a resource from a Lepton RC file is:

@example
(component-library-command list-command get-command name)
@end example

The code adds a new library named @var{name}.  The @var{list-command}
argument specifies a name of the program that will be executed with no
further arguments, and should output a list of available symbol names
on stdout.  The @var{get-command} argument specifies another program
that should take a symbol name as its only argument, and output symbol
data in @ref{gEDA file format} on stdout.

If the command cannot successfully complete, it should exit with
non-zero exit status.  Anything it has output on stdout will be
ignored, and any stderr output displayed to the user.

This is the contents of an example script:

@example
@include cmd-component.sh
@end example

As can be seen from the code, the script can function as list command,
if the option @option{-l} is given, or as get command, if file name is
given.  Otherwise, if no arguments given, it exits with an error code.
If the script is named, say, @file{cmd-component.sh}, then the
following code in @file{gafrc} file will define a new component
library:

@lisp
(define list-command "cmd-component.sh")
(define get-command (string-append list-command " -l"))
(component-library-command list-command get-command "simple-cmd-lib")
@end lisp

Likewise, you can use various symbol generators written in various
languages.

@node component-library-funcs, reset-component-library, component-library-command, Component library setup
@subsubsection component-library-funcs
@cindex component-library-funcs

A set of Scheme procedures can be used as a component resource.  The
procedure used to add such a resource from a Lepton RC file is:

@lisp
(component-library-funcs list-function get-function name)
@end lisp

@var{list-function} and @var{get-function} must both be Guile
procedures.  @var{list-function} takes no arguments, and returns a
list of symbol names as Scheme strings.  @var{get-function} takes a
symbol name as an argument, and returns symbol data in @ref{gEDA file
format} in a Scheme string, or @code{#f} if not known.  The @var{name}
argument specifies the name of the new library.

Thus, the user may take advantage of using currently available Scheme
procedures for creating schematic objects.  For example:

@lisp
@include scm-component.scm
@end lisp

The code defines three symbols.  You can see that some steps are
automated in the example for the first two of them: creating
attributes and stroke parameter setting for line objects.  Some other
things are obscure though, like @code{toplevel} stuff.  However, this
is how it currently works.

You may also notice that the last symbol, @samp{dummy.sym}, is defined
just as a string in the @ref{gEDA file format}.  You can do so as
well, though either you lose any automation, or you have to deal with
strings instead of Lepton Scheme objects.

Put the code in some file and load it from your @file{gafrc}, e.g.:

@lisp
(primitive-load "scm-component.scm")
@end lisp
@noindent
or put it directly to @file{gafrc}.


@node reset-component-library,  , component-library-funcs, Component library setup
@subsubsection reset-component-library
@cindex reset-component-library

@code{reset-component-library} initializes, i.e. empties the global
component library.  Thus, the user can define a new set of component
resources from scratch.  For example, sometimes it is convenient to
get rid of default symbols in the library window of
@schematic{} and work only with those in your own custom
libraries.

Use the command before other component library commands, such as
@ref{component-library}.

Supposed you want some of your projects to use only special symbol
libraries, then the typical usage is as follows.  First reset all
libraries, then populate the component library with your directories,
e.g.:

@lisp
(reset-component-library)

(component-library-search "$@{HOME@}/lepton/symbols")
@end lisp

The good place to do so is @file{gafrc} in your project's directory.
However, you can also disable default libraries completely by writing
such lines in @file{gafrc} in the directory with your user's settings.
@xref{Legacy configuration} for more information on configuration
paths.

@node Interactive work with Scheme code,  , Component libraries, lepton-schematic
@section Interactive work with Scheme code
@cindex using Scheme in GUI

You can extend the functionality of @schematic{}, automate some work
on schematic or symbol creation, and learn how things are internally
made up playing with Scheme without even exiting the program.  There
are several ways to get things done and they are described below.

@quotation Note
You can also work with Scheme using interactive mode of several
non-GUI Lepton utilities, namely, @netlist{}, @cli, and @symcheck{}.
Please read their manual pages on how to run them interactively.
@end quotation

Sometimes it is very convenient to invoke a one-line script to try
some idea.  Use @clicksequence{File @click{} Invoke macro...}
(@kbd{:}, colon, or @kbd{E Shift-:}) to open a macro widget which will
allow you to execute some small excerpts of Scheme code interactively.
In the macro widget entry you may enter one line consisting of one or
more commands in Scheme (don't forget parentheses).  Hit @kbd{Enter}
to make them evaluate and watch the result of your expression in the
@emph{Log window}.  If the script includes some interactive functions,
you'll immediately see the result in GUI.

Another, more powerful possibility is executing a Scheme script stored
in some file in your file system.  It allows you evaluate the code of
any length, so it is much more convenient if you work on some complex
code. Use @clicksequence{File @click{} Execute Script...} (@kbd{F T})
and select a Scheme script to execute.  You can filter the files like
in the @emph{File Open} dialog (@pxref{Creating and opening
schematics}), though you can choose solely amongst showing only Scheme
or any files.  Switch between @schematic{} and your text editor, edit
your code and try again.

The most powerful and convenient way of working with Scheme is using
REPL.  There are two ways to start it:

@itemize

@item
Use @clicksequence{File @click{} REPL...} (@kbd{F Shift-R}) to start
REPL in the background terminal where you started @schematic{}, move
to the terminal and hack your Scheme code interactively.  If you
didn't use a terminal for launching the program, the feature is not
available.

@item
Launch the following code in the macro widget described above, in the
command line using the @option{-c} option (@pxref{lepton-schematic
command line options}), or in one of RC files available for your
project (@pxref{gschemrc}):

@lisp
(use-modules (system repl server)) (spawn-server)
@end lisp

The command will make available a Scheme socket on the port
@emph{37146} for your program.  You can connect to it, for example,
using @command{netcat} or shiny @command{geiser} environment for
@command{Emacs}, and enjoy working with REPL using the program chosen.

@end itemize

In the REPL, you'll immediately see the results of your expressions or
errors, be able to list, edit and use expressions evaluated before,
utilize their results again, load files, and more.  So this option
embraces all the advantages of the former two and adds more.  However,
be careful:

@quotation Caution
Trying some code pieces may be dangerous and crash your running
@schematic{} process while working in the REPL!  The reason is the
lack of proper multi-threading support in GTK while Scheme supports it
pretty well.  If in doubt, save your designs before trying something
out.
@end quotation
